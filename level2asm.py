#!/usr/bin/env python3

def is_level_data(line: str) -> bool:
    """Check if line contains level data (not labels, comments, or empty lines)."""
    return not (':' in line or ';' in line or line.strip() == '')


def count_level_data_lines(level_lines: list) -> int:
    """Count the number of level data lines in a block."""
    return len([line for line in level_lines if is_level_data(line)])


def process_level_block(level_lines: list) -> bool:
    """Process and print a block of level lines. Returns True if block contains level data."""
    if not count_level_data_lines(level_lines):
        return False

    # Calculate max length only from actual level data lines
    max_length = max((len(line) for line in level_lines if is_level_data(line)), default=0)

    while level_lines and not is_level_data(level_lines[0]):
        # Print and remove non-level data lines at the start
        print(level_lines.pop(0))

    for line in level_lines:
        if is_level_data(line):
            formatted_line = f'{line:<{max_length}}'
            print(f'  DB "{formatted_line:^20}"')
        else:
            print(line)

    return True


with open("levels.txt", "r") as f:
    lines = f.read().splitlines()

print("; This file is automatically generated by level2asm.py")
print("; from levels.txt and data.nolevels.asm")
print("; Do not edit this file directly.\n")
with open("data.nolevels.asm", "r") as f:
    print(f.read())
print('\nSECTION "Levels", ROM0')

current_block = []
labels = []
level_num_rows = []
for line in lines:
    if line.endswith(':'):
        # Process previous block before starting new one
        if process_level_block(current_block):
            level_num_rows.append(count_level_data_lines(current_block))
        current_block = []
        labels.append(line.strip().strip(':'))
    current_block.append(line)

# Process final block
if process_level_block(current_block):
    level_num_rows.append(count_level_data_lines(current_block))

print(f'\nLevelEnd:\n\nDEF LEVEL_NUM EQU {len(labels)}\n\nLevelTable:')
for label, num_rows in zip(labels, level_num_rows):
    print(f'  DW {label}')
    print(f'  DB {num_rows}')